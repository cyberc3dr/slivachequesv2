import re
from abc import ABC, abstractmethod
from numbers import Number
from urllib.parse import urlparse, parse_qsl

from telethon import TelegramClient, Button
from telethon.extensions import markdown
from telethon.tl.custom import InlineResults, InlineResult
from telethon.tl.types import Message, PeerUser, MessageEntityTextUrl

import database


def parse_url(s: str):
    s = s.strip("/")
    if s.startswith("://"):
        return urlparse(s[1:])
    elif not re.match("[a-zA-Z]+://.*", s):
        return urlparse("//" + s)
    return urlparse(s)


class Bot(ABC):

    def __init__(self, id: Number, usernames: list[str], display_name: str, icon: str):
        self.id = id
        self.usernames = usernames
        self.display_name = display_name
        self.icon = icon

    def is_duplicated(self, cheque: str) -> bool:
        return database.is_duplicated(self.usernames[0], cheque)

    @abstractmethod
    def is_valid(self, cheque: str, raw_message: str) -> bool:
        pass

    # @abstractmethod
    # async def activate(self, client: TelegramClient, cheque: str):
    #     pass

    @abstractmethod
    async def send_cheque(self, client: TelegramClient, bot: TelegramClient, target: int, cheque: str,
                          original_message: Message, source: str, name: str):
        pass

    @property
    def supports_inline(self) -> bool:
        raise NotImplementedError


class RocketBot(Bot):
    supports_inline = True

    _rocket_valid: list = [
        "mc", "mci", "t"
    ]

    def __init__(self):
        super().__init__(5014831088, ["xrocket", "tonrocketbot"], "xRocket", "üöÄ")

    def is_valid(self, cheque: str, raw_message: str) -> bool:
        if "_" in cheque:
            split = cheque.split("_")
            cheque_type = split[0].lower()
            cheque_hash = split[1]
            if len(cheque_hash) == 15 and cheque_type in self._rocket_valid:
                return True
            return False

    async def send_cheque(self, client: TelegramClient, bot: TelegramClient, target: int, cheque: str,
                          original_message: Message, source: str, name: str):
        results: InlineResults = await client.inline_query(self.usernames[0], cheque)
        if len(results) == 1:
            inline: InlineResult = results[0]
            cheque_type = cheque.split("_")[0].lower()
            if cheque_type in self._rocket_valid:
                url = inline.message.reply_markup.rows[0].buttons[0].url
                if "start" in url:
                    url = dict(parse_qsl(parse_url(url).query))
                    new_cheque: str = url["start"]
                    if new_cheque == cheque or (
                            self.is_valid(new_cheque, inline.message.message) and not self.is_duplicated(new_cheque)):
                        if cheque_type.startswith("mc"):
                            description: str = inline.description
                            if description is not None:
                                cheque_info = description.split(' ¬∑ ')
                                one_activation = cheque_info[0].split(': ')[1]
                                sum = cheque_info[1]
                                activated = cheque_info[2]

                                rocket = False
                                referral = None
                                if len(cheque_info) > 3 and cheque_info[3].strip().endswith("%"):
                                    referral = cheque_info[3].strip()
                                    if referral != "0%":
                                        referral_sum = float(one_activation.split(" ")[0]) * (float(
                                            referral.removesuffix('%')) / 100)
                                        referral = f"{referral_sum} {one_activation.split(' ')[1]} ({referral})"
                                    else:
                                        referral = None
                                    rocket = True

                                premium = False
                                activate_button = inline.message.reply_markup.rows[0].buttons[0]
                                activate_text: str = activate_button.text
                                if "üåü" in activate_text:
                                    activate_text = activate_text.replace('üåü', '').strip()
                                    premium = True
                                activate_text = f"{self.icon} {activate_text}"

                                bot_message: str = markdown.unparse(inline.message.message.
                                                                    replace('[', ' ').
                                                                    replace(']', ' '), inline.message.entities).split(
                                    "\n\n")

                                header = bot_message[0].strip()

                                picture = None
                                if header.startswith('[\u200d]'):
                                    picture = inline.message.entities[0].url

                                requires_password = False
                                if header.endswith("—Å –ø–∞—Ä–æ–ª–µ–º"):
                                    requires_password = True

                                last = len(bot_message) - 1

                                cheque_description = None
                                if last > 1 and bot_message[2].startswith("üí¨"):
                                    cheque_description = "\n\n".join(bot_message[2:]) if last != 2 else bot_message[2]

                                info = [
                                    f"{f'**üöÄ Rocket-—á–µ–∫ ({cheque_type})**' if rocket else '**üíµ –ú—É–ª—å—Ç–∏-—á–µ–∫**'}{' (üåü)' if premium else ''}{' (üîê)' if requires_password else ''} –Ω–∞ **{sum}**",
                                    "",
                                    f"–û–¥–∏–Ω —á–µ–∫: **{one_activation}**",
                                    f"–ê–∫—Ç–∏–≤–∞—Ü–∏–∏: **{activated}**"]

                                if rocket and referral:
                                    info.append(f"–†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è –Ω–∞–≥—Ä–∞–¥–∞: **{referral}**")

                                if cheque_description is not None:
                                    info.append("")
                                    info.append(cheque_description)

                                info.append("")
                                info.append(
                                    f"#TonRocket #{'Rocket' if rocket else '–ú—É–ª—å—Ç–∏'} ${sum.split(' ')[-1].upper()}{' #Premium' if premium else ' #–ë–µ–∑Premium'}{' #–†–µ—Ñ' if referral else ' #–ë–µ–∑–†–µ—Ñ–∞'}{' #–ü–∞—Ä–æ–ª—å' if requires_password else ' #–ë–µ–∑–ü–∞—Ä–æ–ª—è'}")

                                buttons = [[Button.url(activate_text, activate_button.url)],
                                           [Button.url(f"üîé {name}", source)]]

                                if picture:
                                    print(f"sent xrocket cheque with picture {new_cheque}")

                                    await bot.send_file(entity=target, caption="\n".join(info),
                                                        buttons=buttons,
                                                        link_preview=False, file=picture, force_document=False)
                                else:
                                    print(f"sent xrocket cheque {new_cheque}")

                                    await bot.send_message(entity=target, message="\n".join(info),
                                                           buttons=buttons,
                                                           link_preview=False)
                        elif cheque_type == "t":
                            title = inline.title
                            description: str = inline.description.strip()
                            if description is not None and title is not None:
                                sum = " ".join(title.split(" ")[2:])

                                bot_message: str = markdown.unparse(inline.message.message,
                                                                    inline.message.entities).split(
                                    "\n\n")

                                cheque_description = None
                                if len(bot_message) > 1 and bot_message[1].startswith("üí¨"):
                                    cheque_description = "\n\n".join(bot_message[1:])

                                header = inline.message.message.split("\n\n")[0].strip()

                                username = None
                                if not header.endswith(sum):
                                    # username = header.split(" ")[-1]
                                    return

                                info = [
                                    f"**üí∏ –ß–µ–∫** –Ω–∞ **{sum}**{f' –¥–ª—è **{username}**' if username is not None else ''}"]

                                if cheque_description is not None:
                                    info.append("")
                                    info.append(cheque_description)

                                info.append("")
                                info.append(f"#TonRocket #–ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π ${sum.split(' ')[1]}")

                                activate_button = inline.message.reply_markup.rows[0].buttons[0]

                                print(f"sent xrocket personal {cheque}")

                                await bot.send_message(entity=target, message="\n".join(info),
                                                       buttons=[[Button.url(f"{self.icon} {activate_button.text}",
                                                                            activate_button.url)],
                                                                [Button.url(f"üîé {name}", source)]],
                                                       link_preview=False)


class CryptoBot(Bot):
    supports_inline = False

    def __init__(self):
        super().__init__(1559501630, ["cryptobot", "send"], "CryptoBot", "üíé")

    def is_valid(self, cheque: str, raw_message: str) -> bool:
        if cheque.startswith("CQ") and len(cheque) == 12:
            return True
        elif cheque.startswith("G") and len(cheque) == 13:
            return True

    async def send_cheque(self, client: TelegramClient, bot: TelegramClient, target: int, cheque: str,
                          original_message: Message, source: str, name: str):
        if original_message.via_bot_id == self.id:
            md_message: list[str] = markdown.unparse(original_message.message, original_message.entities).split("\n\n")
            str_message: list[str] = original_message.message.split("\n\n")

            # –†–∞–±–æ—Ç–∞ –ø–æ –∑–∞–≥–æ–ª–æ–≤–∫—É
            header = re.sub('\(.*?\)', "", str_message[0].strip().removeprefix("‚Äã").removesuffix(".")).strip()

            gift = header.startswith("üíå")

            activate_button = original_message.reply_markup.rows[0].buttons[0]

            if not gift:
                if "–¥–ª—è" in header or "given to" in header:
                    return

                multi = "–º—É–ª—å—Ç–∏" in header.lower() or "multi-use" in header.lower()

                sum = " ".join(header.split(" ")[-2:])

                currency = header.split(" ")[-1]

                # –ö–∞—Ä—Ç–∏–Ω–∫–∞, –µ—Å–ª–∏ –∏–º–µ–µ—Ç—Å—è
                picture = None
                if md_message[0].startswith("‚Äã"):
                    picture = original_message.entities[0].url

                # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –±–∞–∑–æ–≤—É—é –∏–Ω—Ñ—É
                info = [
                    f"**{'üíµ –ú—É–ª—å—Ç–∏-—á–µ–∫' if multi else 'üí∏ –ß–µ–∫'}** –Ω–∞ **{sum}**"
                ]

                # –û–ø–µ—Ä–∞—Ü–∏–∏ —Å –º—É–ª—å—Ç–∏—á–µ–∫–æ–º
                if multi:
                    activation_info = re.sub('\(.*?\)', "", str_message[1]).split("\n")

                    one_activation = " ".join(activation_info[0].strip().split(" ")[-2:])
                    activation_count = activation_info[1].split(" ")[-1]

                    info.append("")
                    info.append(f"–û–¥–∏–Ω —á–µ–∫: **{one_activation}**")
                    info.append(f"–ê–∫—Ç–∏–≤–∞—Ü–∏–∏: **{activation_count}**")

                first = 2 if multi else 1

                if len(md_message) > first and md_message[first].strip().startswith("üí¨"):
                    cheque_description = "\n\n".join(
                        md_message[first:]) if len(md_message) - 1 != first else md_message[first]

                    info.append("")
                    info.append(cheque_description)

                info.append("")
                info.append(f"#CryptoBot #{'–ú—É–ª—å—Ç–∏' if multi else '–ß–µ–∫'} ${currency} #–ò–Ω–ª–∞–π–Ω")

                if picture is not None:
                    print(f"sent cryptobot cheque with picture {cheque}")

                    await bot.send_file(entity=target, caption="\n".join(info),
                                        buttons=[
                                            [Button.url(f"{self.icon} {activate_button.text}", activate_button.url)],
                                            [Button.url(f"üîé {name}", source)]],
                                        link_preview=False, file=picture, force_document=False)
                else:
                    print(f"sent cryptobot cheque {cheque}")

                    await bot.send_message(entity=target, message="\n".join(info),
                                           buttons=[
                                               [Button.url(f"{self.icon} {activate_button.text}", activate_button.url)],
                                               [Button.url(f"üîé {name}", source)]],
                                           link_preview=False)
            else:
                if not ("–¥–ª—è —Ç–µ–±—è" in header or "for you" in header):
                    return

                info = [
                    f"**üíå –í–∞–ª–µ–Ω—Ç–∏–Ω–∫–∞** ",
                    f"",
                    f"(–º–æ–∂–µ—Ç –∑–∞–±—Ä–∞—Ç—å –ª—é–±–æ–π)",
                    f"",
                    f"#CryptoBot #–í–∞–ª–µ–Ω—Ç–∏–Ω–∫–∞"]

                print(f"sent cryptobot gift {cheque}")

                await bot.send_message(entity=target, message="\n".join(info),
                                       buttons=[
                                           [Button.url(f"{self.icon} –ü–æ–ª—É—á–∏—Ç—å –≤–∞–ª–µ–Ω—Ç–∏–Ω–∫—É", activate_button.url)],
                                           [Button.url(f"üîé {name}", source)]],
                                       link_preview=False)
        elif original_message.fwd_from is not None and isinstance(original_message.fwd_from.from_id,
                                                                  PeerUser) and original_message.fwd_from.from_id.user_id == self.id:
            md_message: list[str] = markdown.unparse(original_message.message, original_message.entities).split("\n\n")
            str_message: list[str] = original_message.message.split("\n\n")

            picture = None
            if md_message[0].startswith("[\u200b]"):
                picture = original_message.entities[0].url

            multi = True if str_message[0].endswith("–ú—É–ª—å—Ç–∏—á–µ–∫") else False

            sums = str_message[1]

            last = len(md_message) - 3

            one_activation = None
            activation_count = None
            done = None
            if multi:
                split = sums.split("\n")

                sum = split[0].split(": ")[1]
                one_activation = " ".join(split[1].split(": ")[1].split(" ")[1:])

                activations_text = md_message[2].split("\n")
                activation_count = activations_text[0].split(": ")[1]
                done = activations_text[1].split(" ")[1]
            else:
                sum = " ".join(sums.split(": ")[1].split(" ")[1:])

            start = 3 if multi else 2
            cheque_description = None
            if md_message[start].startswith("üí¨"):
                cheque_description = "\n\n".join(md_message[start:last]) if last != start else md_message[last]

            cq_target = md_message[last]

            is_premium = "Premium" in cq_target
            new = "new users" in cq_target or "–Ω–æ–≤—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å" in cq_target
            has_password = "–≤–≤–æ–¥–∞ –ø–∞—Ä–æ–ª—è" in cq_target or "password" in cq_target

            username = None
            if not is_premium and not new and (cq_target.startswith("Only") or cq_target.startswith("–¢–æ–ª—å–∫–æ")):
                # username = target.split(" ")[1]
                return

            info = [
                f"{'**üíµ –ú—É–ª—å—Ç–∏-—á–µ–∫**' if multi else '**üí∏ –ß–µ–∫**'}{' (üåü)' if is_premium else ''}{' (üîê)' if has_password else ''}{' (üÜï)' if new else ''} –Ω–∞ {sum}{f' –¥–ª—è {username}' if username is not None else ''}"
            ]

            if multi:
                info.append(" ")
                info.append(f"–û–¥–∏–Ω —á–µ–∫: **{one_activation}**")
                info.append(f"–ê–∫—Ç–∏–≤–∞—Ü–∏–π: **{done}** / {activation_count}")

            if cheque_description is not None:
                info.append(" ")
                info.append(cheque_description)

            info.append(" ")
            info.append(
                f"#CryptoBot #Forward #{'–ú—É–ª—å—Ç–∏' if multi else '–ß–µ–∫'} ${sum.split(' ')[1]}{' #Premium' if is_premium else ' #–ë–µ–∑Premium'}{' #–ü–∞—Ä–æ–ª—å' if has_password else ' #–ë–µ–∑–ü–∞—Ä–æ–ª—è'}{' #–î–ª—è–ù–æ–≤—ã—Ö' if new else ' #–î–ª—è–í—Å–µ—Ö'}")

            if picture is not None:
                print(f"sent cryptobot forward with picture {cheque}")

                await bot.send_file(entity=target, caption="\n".join(info),
                                    buttons=[[Button.url(f"{self.icon} –ü–æ–ª—É—á–∏—Ç—å {one_activation if multi else sum}",
                                                         f"https://t.me/CryptoBot?start={cheque}")],
                                             [Button.url(f"üîé {name}", source)]],
                                    link_preview=False, file=picture, force_document=False)
            else:
                print(f"sent cryptobot forward {cheque}")

                await bot.send_message(entity=target, message="\n".join(info),
                                       buttons=[[Button.url(f"{self.icon} –ü–æ–ª—É—á–∏—Ç—å {one_activation if multi else sum}",
                                                            f"https://t.me/CryptoBot?start={cheque}")],
                                                [Button.url(f"üîé {name}", source)]],
                                       link_preview=False)
        else:
            str_message: list[str] = original_message.message.split("\n\n")

            giveaway = cheque.startswith("G")

            header = re.sub('\(.*?\)', "", str_message[0].strip().removeprefix("‚Äã")).strip()

            if giveaway and header.startswith("üéÅ"):
                rus = "–†–æ–∑—ã–≥—Ä—ã—à" in header

                sum = " ".join(header.split(" ")[-2:])
                currency = header.split(" ")[-1]

                count_info = re.sub('[ ]+(?=\s)', '', re.sub('\(.*?\)', "", str_message[1].strip().removesuffix(".")).strip()).split(" ")
                winners = count_info[0] if rus else count_info[13]
                each = " ".join(count_info[-2:] if rus else count_info[-3:-1])

                channels = []

                entities = original_message.entities
                if entities is not None:
                    for entity in entities:
                        if isinstance(entity, MessageEntityTextUrl):
                            url = entity.url

                            if "CryptoBot" not in url:
                                channels.append(url)

                if rus:
                    timings = str_message[3].split(" ")

                    time = " ".join(timings[:5])
                else:
                    time = " ".join(count_info[1:6])

                info = [
                    f"üéÅ **–†–æ–∑—ã–≥—Ä—ã—à** –Ω–∞ **{sum}**",
                    "",
                    f"**–û–¥–Ω–∞ –ø–æ–±–µ–¥–∞:** {each}",
                    f"**–ü–æ–±–µ–¥–∏—Ç–µ–ª–µ–π:** {winners}",
                    ""
                    f"**–ó–∞–∫–æ–Ω—á–∏—Ç—Å—è**: {time}",
                    "",
                    "**–ù—É–∂–Ω–æ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è:**"
                ]

                for channel in channels:
                    info.append(channel)

                info.append("")
                info.append(f"#CryptoBot #–†–æ–∑—ã–≥—Ä—ã—à #{currency}")

                print(f"sent cryptobot giveaway {cheque}")

                await bot.send_message(entity=target, message="\n".join(info),
                                       buttons=[[Button.url(f"{self.icon} –ü—Ä–∏–Ω—è—Ç—å —É—á–∞—Å—Ç–∏–µ",
                                                            f"https://t.me/CryptoBot?start={cheque}")],
                                                [Button.url(f"üîé {name}", source)]],
                                       link_preview=False)
            else:
                info = [f"{'–†–æ–∑—ã–≥—Ä—ã—à' if giveaway else '–ß–µ–∫'} (–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞)",
                        "",
                        f"#CryptoBot #–°—Å—ã–ª–∫–∞{' #–†–æ–∑—ã–≥—Ä—ã—à' if giveaway else ''}"]

                print(f"sent cryptobot unknown {'giveaway' if giveaway else 'cheque'} {cheque}")

                await bot.send_message(entity=target, message="\n".join(info),
                                       buttons=[[Button.url(f"{self.icon} –ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å",
                                                            f"https://t.me/CryptoBot?start={cheque}")],
                                                [Button.url(f"üîé {name}", source)]],
                                       link_preview=False)


class Wallet(Bot):
    supports_inline = True

    def __init__(self):
        super().__init__(1985737506, ["wallet"], "Wallet", "üíµ")

    def is_valid(self, cheque: str, raw_message: str) -> bool:
        if cheque.startswith("C-") and len(cheque) == 12:
            return True

    async def send_cheque(self, client: TelegramClient, bot: TelegramClient, target: int, cheque: str,
                          original_message: Message, source: str, name: str):
        results: InlineResults = await client.inline_query(self.usernames[0], cheque)
        if len(results) == 1:
            inline: InlineResult = results[0]
            title: str = inline.title
            if title is not None:
                multi = title.endswith("–º—É–ª—å—Ç–∏—á–µ–∫")

                bot_message: str = markdown.unparse(inline.message.message, inline.message.entities).split("\n\n")

                if multi:
                    sum: str = " ".join(bot_message[0].split(" ")[3:])
                    currency = sum.split(" ‚âà ")[0].split(" ")[1].upper()

                    activations = bot_message[1].split("\n")
                    one_activation = activations[0].split(": ")[1]
                    activation_count = activations[1].split(": ")[1]

                    if float(one_activation.split(" ")[0]) < 0.0002:
                        return

                    info = [f"**üíµ –ú—É–ª—å—Ç–∏—á–µ–∫** –Ω–∞ **{sum}**",
                            "",
                            f"–û–¥–∏–Ω —á–µ–∫: **{one_activation}**",
                            f"–ê–∫—Ç–∏–≤–∞—Ü–∏–π: **{activation_count}**"]
                else:
                    sum: str = " ".join(bot_message[0].split(" ")[3:])

                    if float(sum.split(" ")[0]) < 0.0002:
                        return

                    currency = sum.split(" ‚âà ")[0].split(" ")[1]

                    info = [f"**üí∏ –ß–µ–∫** –Ω–∞ **{sum}**"]

                info.append("")
                info.append(f"#Wallet{' #–ú—É–ª—å—Ç–∏' if multi else ' #–ß–µ–∫'} ${currency}")

                activate_button = inline.message.reply_markup.rows[0].buttons[0]

                print(f"send wallet cheque {cheque}")

                await bot.send_message(entity=target, message="\n".join(info),
                                       buttons=[[Button.url(f"{self.icon} {activate_button.text}",
                                                            activate_button.url)],
                                                [Button.url(f"üîé {name}", source)]],
                                       link_preview=False)


class BotRegistry:
    bots: list[Bot] = [
        RocketBot(),
        CryptoBot(),
        Wallet(),
        # JTonBot(),
        # XJetSwap(),
        # Jetton()
    ]

    def get_by_id(self, id: Number):
        if id is not None:
            for bot in self.bots:
                if bot.id == id:
                    return bot
        return None

    def get_by_username(self, username: str):
        if username is not None:
            for bot in self.bots:
                if username.lower() in bot.usernames:
                    return bot
        return None


registry = BotRegistry()
